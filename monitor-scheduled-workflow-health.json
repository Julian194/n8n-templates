{
  "name": "Monitor - Scheduled Workflow Health",
  "nodes": [
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [-1100, -200],
      "id": "a1000000-0000-0000-0000-000000000001",
      "name": "Manual Trigger"
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "hours",
              "hour": 9
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [-1100, -400],
      "id": "a1000000-0000-0000-0000-000000000002",
      "name": "Daily 9am"
    },
    {
      "parameters": {
        "resource": "workflow",
        "operation": "getAll",
        "returnAll": true,
        "filters": {
          "active": true
        }
      },
      "type": "n8n-nodes-base.n8n",
      "typeVersion": 1,
      "position": [-860, -300],
      "id": "a1000000-0000-0000-0000-000000000003",
      "name": "Get Active Workflows"
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "language": "javaScript",
        "jsCode": "// Auto-discover scheduled/polling workflows and calculate max age.\n// Customize: set projectId to limit to a specific n8n project, or leave empty to monitor all.\nconst workflows = $input.all().map(i => i.json);\nconst skipTag = 'skip-monitoring';\nconst projectId = ''; // optional: set to your n8n project ID to scope monitoring\nconst results = [];\n\nfor (const wf of workflows) {\n  if (wf.isArchived) continue;\n  if (projectId) {\n    const wfProject = wf.shared?.[0]?.projectId;\n    if (wfProject !== projectId) continue;\n  }\n  const tags = (wf.tags || []).map(t => (t.name || t).toString().toLowerCase());\n  if (tags.includes(skipTag)) continue;\n\n  const nodes = wf.nodes || [];\n  const scheduleTrigger = nodes.find(n => n.type === 'n8n-nodes-base.scheduleTrigger');\n  const pollingTrigger = nodes.find(n =>\n    n.type.includes('Trigger') &&\n    n.type !== 'n8n-nodes-base.manualTrigger' &&\n    n.type !== 'n8n-nodes-base.executeWorkflowTrigger' &&\n    n.type !== 'n8n-nodes-base.errorTrigger' &&\n    n.type !== 'n8n-nodes-base.scheduleTrigger' &&\n    n.parameters?.pollTimes\n  );\n\n  if (!scheduleTrigger && !pollingTrigger) continue;\n\n  let maxAgeHours = 48; // safe default: 2 days\n\n  if (scheduleTrigger) {\n    const interval = scheduleTrigger.parameters?.rule?.interval?.[0];\n    if (interval) {\n      if (interval.field === 'cronExpression' && interval.expression) {\n        maxAgeHours = parseCronMaxAge(interval.expression);\n      } else if (interval.field === 'minutes') {\n        const mins = interval.minutesInterval || 30;\n        maxAgeHours = Math.max(2, Math.ceil(mins * 8 / 60));\n      } else if (interval.field === 'hours') {\n        maxAgeHours = 48;\n      } else if (interval.field === 'weeks') {\n        maxAgeHours = 192; // 8 days\n      } else if (interval.field === 'months') {\n        maxAgeHours = 840; // 35 days\n      } else {\n        maxAgeHours = 48; // default daily: {triggerAtHour: N}\n      }\n    }\n  }\n  // polling triggers keep default 48h\n\n  results.push({ json: { workflowId: wf.id, name: wf.name, maxAgeHours } });\n}\n\nfunction parseCronMaxAge(expr) {\n  const parts = expr.trim().split(/\\s+/);\n  if (parts.length < 5) return 48;\n  const [min, hour, dom, month, dow] = parts;\n\n  // Monthly: specific day of month (e.g. \"0 9 1 * *\")\n  if (dom !== '*' && !dom.startsWith('*/')) return 840;\n  // Weekday-only schedules: 48h covers the weekend gap\n  if (dow !== '*') return 48;\n  // Every N days (e.g. \"0 9 */2 * *\")\n  if (dom.startsWith('*/')) {\n    const n = parseInt(dom.split('/')[1]) || 1;\n    return Math.max(48, n * 36);\n  }\n  // Sub-hourly (e.g. \"*/15 8-17 * * *\")\n  if (min.startsWith('*/')) return 48;\n  // Daily\n  return 48;\n}\n\nreturn results;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-620, -300],
      "id": "a1000000-0000-0000-0000-000000000004",
      "name": "Discover Scheduled"
    },
    {
      "parameters": {
        "resource": "execution",
        "limit": 1,
        "filters": {
          "workflowId": {
            "__rl": true,
            "value": "={{ $json.workflowId }}",
            "mode": "id"
          }
        },
        "options": {},
        "requestOptions": {}
      },
      "type": "n8n-nodes-base.n8n",
      "typeVersion": 1,
      "position": [-380, -300],
      "id": "a1000000-0000-0000-0000-000000000005",
      "name": "Get Latest Execution",
      "onError": "continueRegularOutput",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "mode": "runOnceForAllItems",
        "language": "javaScript",
        "jsCode": "// Match execution results with discovered config, flag stale workflows\nconst executions = $input.all().map(i => i.json);\nconst config = $('Discover Scheduled').all().map(i => i.json);\n\n// Build map: workflowId -> latest execution\nconst execMap = {};\nfor (const exec of executions) {\n  if (exec.workflowId) {\n    execMap[exec.workflowId] = exec;\n  }\n}\n\nconst stale = [];\nconst ok = [];\n\nfor (const c of config) {\n  const exec = execMap[c.workflowId];\n  if (!exec || !exec.startedAt) {\n    stale.push({ name: c.name, reason: 'No execution found' });\n  } else {\n    const ageHours = (Date.now() - new Date(exec.startedAt).getTime()) / (1000 * 60 * 60);\n    if (ageHours > c.maxAgeHours) {\n      stale.push({\n        name: c.name,\n        reason: `Last ran ${Math.round(ageHours)}h ago (max: ${c.maxAgeHours}h)`,\n        lastRun: exec.startedAt\n      });\n    } else {\n      ok.push(c.name);\n    }\n  }\n}\n\nreturn [{ json: { stale, staleCount: stale.length, okCount: ok.length, checkedCount: config.length } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-140, -300],
      "id": "a1000000-0000-0000-0000-000000000006",
      "name": "Check Staleness"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "combinator": "and",
          "conditions": [
            {
              "id": "1",
              "leftValue": "={{ $json.staleCount }}",
              "rightValue": 0,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ]
        }
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [100, -300],
      "id": "a1000000-0000-0000-0000-000000000007",
      "name": "Any Stale?"
    },
    {
      "parameters": {
        "errorMessage": "={{ $json.staleCount }} scheduled workflow(s) missed their schedule:\n{{ $json.stale.map(s => '• ' + s.name + ' — ' + s.reason).join('\\n') }}"
      },
      "type": "n8n-nodes-base.stopAndError",
      "typeVersion": 1,
      "position": [340, -400],
      "id": "a1000000-0000-0000-0000-000000000008",
      "name": "Stop and Error"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [340, -200],
      "id": "a1000000-0000-0000-0000-000000000009",
      "name": "All Good"
    }
  ],
  "connections": {
    "Manual Trigger": {
      "main": [
        [
          {
            "node": "Get Active Workflows",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Daily 9am": {
      "main": [
        [
          {
            "node": "Get Active Workflows",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Active Workflows": {
      "main": [
        [
          {
            "node": "Discover Scheduled",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Discover Scheduled": {
      "main": [
        [
          {
            "node": "Get Latest Execution",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Latest Execution": {
      "main": [
        [
          {
            "node": "Check Staleness",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Staleness": {
      "main": [
        [
          {
            "node": "Any Stale?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Any Stale?": {
      "main": [
        [
          {
            "node": "Stop and Error",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "All Good",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  }
}
